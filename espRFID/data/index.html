<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="icon" href="favicon-48x48.png" sizes="48x48" type="image/png">
    

    <title>Evil Corp</title>
    <style type="text/css">

        body {
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 0;
			
			background-image: url('pic_01.jpg');	/* Background pic*/

			background-repeat: no-repeat;           /* It is not repeated. */
			background-position: center center;     /* Centered */
			background-attachment: fixed;           /* Does not scroll with content */
            
        }
        .container {
            width: 90%;
            margin: 0 auto;
        }
        .controls {
            margin: 20px 0;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        select, button {
            padding: 6px 10px;
            margin-right: 5px;
            font-size: 13px;
        }
        .chart-container {
            width: 60%;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .user-info {
            margin-bottom: 20px;
            font-size: 16px;
        }
    

		h2 {
		    color: #333;
		    font-size: 1.5rem;
		}
    
        h3,
        h4,
        h5,
        b {
            font-weight: 700;
        }

        h1 {
            font-weight: 900;
        }

        button {
            font-weight: 400;
        }

        label {
            font-weight: 500;
        }

        section {
            margin: 1.5em;
            border: 1px solid black;
            padding: 1em;
            width: 90%;
        }

        section>h2 {
            background-color: white;
            margin-top: -1.5em;
            width: max-content;
            padding: 0 0.5em;
            margin-left: 0.5em;
            
        }


        .container {
            width: 80%;
            margin: auto;
        }
        
        .chart-container {
            width: 60%;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
		.table-container {
			width: 90%;
			max-width: 90%; 								/* Does not exceed parent width */
			overflow-x: auto; 								/* Horizontal scroll if needed */
			margin: 20px auto; 								/* Centers the table */
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); 		/* Light shadow for framing */
			border-radius: 8px; 							/* Rounded corners */
			background: white; 								/* Background for contrast */
			opacity: 0.9; 									/* Value between 0 (fully transparent) and 1 (fully opaque) */
		}

		table {
			width: 80%; 									/* Expands maximally within container */
			border-collapse: collapse;
			min-width: 600px; 								/* Minimum width (for small screens) */
			margin: 20px auto; 								/* Centers the table */
		}

        
        /***********************        Navbar styling       ***********************/
        
        /***************************************************************************/
        .navbar {
			background-color: #444444;             /* Dark background color for the navbar */
			padding: 10px;                         /* Adds padding around navbar */
			text-align: center;                    /* Centers navbar content */
		}



        /* Styling for links in the navbar */
        .navbar a {
			color: white;                           /* Sets link text color to white */
			padding: 10px;                          /* Adds padding inside the links */
			text-decoration: none;                  /* Removes underline from the links */
			margin: 0 10px;                         /* Adds horizontal spacing between links */
			font-family: "Lato", sans-serif;        /* Sets a clean sans-serif font for the links */
			font-size: 18px;                        /* Makes the font size larger for readability */
			text-transform: uppercase;              /* Makes the link text uppercase */
			cursor: pointer;                        /* Changes cursor to pointer on hover */
			transition: color 0.5s;                 /* Smooth color transition on hover */
			position: relative;                     /* Needed for pseudo-element positioning */
		}




        /* Hover effects for navbar links */
        .navbar a:hover {
			background-color: #555555; 				/* Lighter background on hover */
			color: #95a5a6; 						/* Changes text color on hover */
        }


		/* Adds an underline effect on navbar links on hover */
        .navbar a::after {
			content: "";                            /* Creates a pseudo-element */
			position: absolute;                     /* Positions the pseudo-element */
			width: 100%;                            /* Full width for the underline */
			height: 2px;                            /* Height of the underline */
			top: 100%;                              /* Places it below the link */
			left: 0;
			background: #ff7000;                    /* Orange color for the underline */
			transition: transform 0.5s;             /* Smooth animation */
			transform: scaleX(0);                   /* Starts as invisible */
			transform-origin: right;                /* Animation grows from the right side */
		}


        .navbar a:hover::after {
			transform: scaleX(1);                   /* Expands the underline on hover */
			transform-origin: left;                 /* Animation grows to the left */
        }


		/* Navbar list styling */
        .navbar ul {
			display: flex;                          /* Uses flexbox to layout the items */
			gap: 2rem;                              /* Adds horizontal space between items */
			list-style-type: none;                  /* Removes default list styling */
			margin: 0;                              /* Removes default margin */
			padding: 0;                             /* Removes default padding */
			width: 100%;                            /* Makes the list take the full width */
			justify-content: space-between;         /* Distributes items between left and right */
		}	


		/* Aligns logout button to the far right */
        .navbar>ul>li:last-child {
            margin-left: auto;						/* This pushes the logout button to the far right */
        }
        



        /***************************        Glitch       ***************************/
        						/*Box-sizing for all elements */
        /***************************************************************************/
        *,
        *::after,
        *::before {
            box-sizing: border-box;
        }

        .stack {
            display: grid;
            grid-template-columns: 1fr;
        }

        .stack span {
            font-weight: bold;
            grid-row-start: 1;
            grid-column-start: 1;
            font-size: 2rem;
            --stack-height: calc(100% / var(--stacks) - 1px);
            --inverse-index: calc(calc(var(--stacks) - 1) - var(--index));
            --clip-top: calc(var(--stack-height) * var(--index));
            --clip-bottom: calc(var(--stack-height) * var(--inverse-index));
            clip-path: inset(var(--clip-top) 0 var(--clip-bottom) 0);
            animation: stack 340ms cubic-bezier(.46, .29, 0, 1.24) 1 backwards calc(var(--index) * 120ms), glitch 2s ease infinite 2s alternate-reverse;
        }

        .stack span:nth-child(odd) {
            --glitch-translate: 8px;
        }

        .stack span:nth-child(even) {
            --glitch-translate: -8px;
        }

        @keyframes stack {
            0% {
                opacity: 0;
                transform: translateX(-50%);
                text-shadow: -2px 3px 0 red, 2px -3px 0 blue;
            }

            ;

            60% {
                opacity: 0.5;
                transform: translateX(50%);
            }

            80% {
                transform: none;
                opacity: 1;
                text-shadow: 2px -3px 0 red, -2px 3px 0 blue;
            }

            100% {
                text-shadow: none;
            }
        }

        @keyframes glitch {
            0% {
                text-shadow: -2px 3px 0 red, 2px -3px 0 blue;
                transform: translate(var(--glitch-translate));
            }

            2% {
                text-shadow: 2px -3px 0 red, -2px 3px 0 blue;
            }

            4%,
            100% {
                text-shadow: none;
                transform: none;
            }
        }




    
        /***********************          tt-symbol         ***********************/
        
        /***************************************************************************/
        #tt-symbol {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 10px;
            border-radius: 5px;
        }
        
        
        
        

        /********************   Style for the time container     *******************/
        
        /***************************************************************************/
        /* Time container styling */
        #time-container {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* Refresh button styling */
        #refresh-time {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            font-size: 16px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        #refresh-time:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* Tooltip styling */
        #refresh-time::after {
            content: "Update ESP32 time.";
            position: absolute;
            bottom: 150%;
            left: 50%;
            transform: translateX(-50%);
            background-color:  #16a085 ;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            width: 220px;
            text-align: center;
            margin-bottom: 10px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #refresh-time:hover::after {
            opacity: 1;
        }

        /* Rotating animation */
        .rotating {
            animation: spin 0.5s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Time text container */
        #time-text {
            display: flex;
            flex-direction: column;
            line-height: 1.5;
        }

        /* Timezone text */
        #timezone {
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 4px;
        }

        /* Notification styling */
        .notification {
            position: fixed;
            bottom: 100px;
            left: 10px;
            background-color: #4CAF50;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            z-index: 10001;
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .notification.error {
            background-color: #f44336;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        
    </style>
</head>

<body>
    <div class="container">
        <!-- Navigation bar section -->
        <nav class="navbar">
            <ul>
                <!-- Link to the Home page -->
                <li><a href="/" id="index">Home</a></li>
                
                <!-- Link to the Access Point (AP) Settings -->
                <li><a href="list.html" id="list">RFID List</a></li>
                
                <!-- Link to the Chart page -->
                <li><a href="chart.html" id="chartLink">Chart</a></li>
                
                <!-- Link to the About page -->
                <li><a href="https://medium.com/@im0nk3yar0und" id="aboutLink">About</a></li>
            </ul>
        </nav>
    </div>

	<br><br>


    <!-- Section displaying a stacked "Evil Corp" text effect -->
    <div class="container">
        <div class="stack" style="--stacks: 3;">
            <span style="--index: 0;">Evil Corp</span>
            <span style="--index: 1;">Evil Corp</span>
            <span style="--index: 2;">Evil Corp</span>
        </div>
    </div>
    
	<br>

    <div class="container">
        <div class="text"></div>
    </div>
    
    <br><br>

<div class="container">
    <div class="table-container">

        <section>
            <h2>Spoof RFID</h2>
            <p><b>Description:</b></p>
            <p>This function allows you to impersonate a valid RFID card by sending a forged ID that matches the target's card.</p>
            <p>It’s useful for testing authentication systems against spoofing vulnerabilities.</p>
            <br>
            <label for="originalId">Original RFID ID:</label>
            <input type="text" id="originalId" placeholder="Hex, e.g. 0xA1B2C3D4">
            <label for="targetId">Target RFID ID (our ID):</label>
            <input type="text" id="targetId" placeholder="Hex, e.g. 0xA1B2C3D4">
            <button onclick="startSpoof()">Add to spoof list</button>
            <button onclick="clearList()">Clear List</button>
        </section>

        <br>

        <section>
            <h2>Replay Attack</h2>
            <p><b>Description:</b></p>
            <p>This attack reuses previously captured RFID communication to gain unauthorized access.</p>
            <p>It doesn’t alter the data, but instead replays a valid transaction to trick the system.</p>
            <br>
            <label for="replayId">RFID Hex:</label>
            <input type="text" id="replayId" placeholder="Hex, e.g. 0xA1B2C3D4">
            <button onclick="startReplay()">Start Replay Attack</button>
        </section>

        <br>

        <section>
            <h2>DoS Attack</h2>
            <p><b>Description:</b></p>
            <p>Denial of Service (DoS) attack sends malformed or junk RFID data to the system in an attempt to overwhelm or crash the RFID reader or backend system.</p>
            <p>Useful for testing system robustness under malicious input.</p>
            <br>
            <label for="dosId">Malicious Hex:</label>
            <input type="text" id="dosId" placeholder="Hex, e.g. 0xFFFFFFFF">
            <button onclick="startDos()">Start DoS Attack</button>
            <button onclick="stopDos()">Stop DoS Attack</button>
        </section>

		<br>
		
		<section style="border: 2px solid #ff4500; padding: 15px; border-radius: 8px; margin-top: 20px;">
			<h2 style="color: #ff6e40;">⚠️ Warning</h2>
			
			<p>This functionality is provided for educational and research purposes only. It is a proof of concept (PoC).</p>
			<p>The author does not take responsibility for any damage, misuse, or legal consequences resulting from unauthorized use of this tool.</p>
			<p>Always ensure you have proper authorization before performing any tests.</p>
		</section>


	</div>
</div>

    <br><br>

    <div id="tt-symbol">TT</div>

    <div id="time-container">
        <div id="time-text">
            <div id="current-time"></div>
            <div id="current-date"></div>
            <div id="timezone"></div>
        </div>
        <button id="refresh-time" title="">⟳</button>
    </div>








<script>
/**
 * Handles the spoofing of RFID IDs by validating user input and sending a request to the backend.
 *
 * Functionality:
 * - Accepts an original RFID ID and a target RFID ID in hexadecimal format (e.g., 0xA1B2C3D4).
 * - Validates both inputs:
 *   - Must start with "0x".
 *   - Must contain 1 to 9 hexadecimal characters (which corresponds to a maximum of 36 bits).
 *   - Original and target IDs must not be identical (case-insensitive check).
 * - If the inputs pass all validations, a GET request is sent to the `/spoof` endpoint with the provided IDs.
 * - If an error occurs, it logs the issue and shows an alert to the user.
 *
 * This function is typically used in RFID security testing scenarios such as spoofing attacks,
 * where the goal is to impersonate another RFID tag using a custom ID.
 */
function startSpoof() {
    const original = document.getElementById("originalId").value.trim();
    const target = document.getElementById("targetId").value.trim();

    // Regex for hex with prefix 0x and maximum 9 characters (36 bits)
    const hexPattern = /^0x[0-9A-Fa-f]{1,9}$/;

    // Format validation
    if (!hexPattern.test(original)) {
        alert("Invalid Original RFID format. Must start with 0x and contain up to 9 hex characters (36 bits).");
        return;
    }

    if (!hexPattern.test(target)) {
        alert("Invalid Target RFID format. Must start with 0x and contain up to 9 hex characters (36 bits).");
        return;
    }

    // Checking that they are not the same
    if (original.toLowerCase() === target.toLowerCase()) {
        alert("Original and Target RFID IDs must be different.");
        return;
    }

    // Sending a spoof request
    fetch(`/spoof?original=${encodeURIComponent(original)}&target=${encodeURIComponent(target)}`)
        .then(response => {
            if (!response.ok) {
                // If response is not OK, read the error message
                return response.text().then(text => {
                    throw new Error(text || 'Spoof failed');
                });
            }
            return response.json(); // Parse JSON for successful responses
        })
        .then(data => {
            // Success case - show success message from server or default
            const message = data.message || "Spoof saved successfully";
            alert(message);
        })
        .catch(error => {
            console.error('Spoof error:', error);
            // Show the actual server error message or fallback
            alert(error.message || 'Failed to spoof RFID');
        });
}


        
        
/**
 * Executes a Replay Attack by resending a previously captured RFID signal to the backend.
 *
 * Functionality:
 * - Takes an RFID ID input in hexadecimal format (e.g., 0xA1B2C3D4).
 * - Validates that the input:
 *   - Starts with "0x".
 *   - Contains 1 to 9 hexadecimal characters (corresponding to up to 36 bits).
 * - If valid, sends a GET request to the `/replay` endpoint with the provided ID as a query parameter.
 * - This simulates the replay of a legitimate RFID scan, which can be used to test the system's resistance to replay-based attacks.
 * - If the request fails or an error occurs, it logs the error and alerts the user.
 *
 * This function is typically used in security testing environments to demonstrate vulnerabilities where RFID systems do not properly validate timestamps, session tokens, or freshness of incoming data.
 */

function startReplay(rfidHex) {
    const id = document.getElementById("replayId").value;
    if (!/^0x[0-9A-Fa-f]{1,9}$/.test(id)) {
        alert("Invalid hex RFID format. Must start with 0x and contain 1-9 hex characters.");
        return;
    }
    fetch(`/replay?original=${id}`)
        .then(response => {
            if (!response.ok) throw new Error('Replay Attack failed');
        })
        .catch(error => {
            console.error('Replay Attack error:', error);
            alert('Replay Attack failed');
        });
}







/**
 * Clears the entire spoofing list stored on the backend.
 *
 * Functionality:
 * - Sends a GET request to the `/clearspooflist` endpoint to remove all spoof entries.
 * - If the request succeeds, alerts the user that the list has been cleared successfully.
 * - If the request fails, logs the error to the console and alerts the user of the failure.
 *
 */
function clearList() {
    fetch(`/clearspooflist`)
        .then(response => {
            if (!response.ok) throw new Error('Clearing the list failed.');
            alert('List cleared successfully!');
        })
        .catch(error => {
            console.error('Clear List error:', error);
            alert('Clear List failed: ' + error.message);
        });
}







/**
 * Executes a Denial-of-Service (DoS) attack simulation by sending a malformed or malicious RFID ID.
 *
 * Functionality:
 * - Accepts a hexadecimal RFID ID input (e.g., 0xDEADBEEF).
 * - Validates that the input:
 *   - Starts with "0x".
 *   - Contains 1 to 9 hexadecimal characters (up to 36 bits).
 * - If valid, sends a GET request to the `/dos` endpoint with the given ID.
 * - This simulates an attempt to overload or disrupt the RFID system with invalid or malicious data.
 * - Does not expect a response from the server; intended primarily for testing system resilience.
 * - Alerts the user in case of invalid input.
 *
 * This function is typically used in penetration testing scenarios to assess how well an RFID-based system can handle malformed or repeated invalid input.
 */
function startDos() {
    const id = document.getElementById("dosId").value.trim();

    const hexPattern = /^0x[0-9A-Fa-f]{1,9}$/;

    if (!hexPattern.test(id)) {
        alert("Invalid hex RFID format. Must start with 0x and contain up to 9 hex characters (36 bits).");
        return;
    }

    fetch(`/dos?id=${id}`)
	  .then(response => response.json())
	  .then(data => {
		  if (data.status === "success") {
		      alert("DoS attack triggered!");
		  } else {
		      alert("Failed: " + data.message);
		  }
	  })
	  .catch(error => {
		  console.error("DoS error:", error);
		  alert("DoS attack failed");
	  });
}





/**
 * Stops an ongoing Denial of Service (DoS) attack on the backend.
 *
 * Functionality:
 * - Sends a GET request to the `/stopdos` endpoint to terminate the DoS attack.
 * - Expects a JSON response indicating success or failure.
 * - If successful, alerts the user that the DoS attack has been stopped.
 * - If the backend reports failure or an error occurs during the request, alerts the user accordingly.
 *
 */
function stopDos() {
	fetch(`/stopdos`)
	  .then(response => response.json())
	  .then(data => {
		  if (data.status === "success") {
			  alert("Stoping DoS attack success!");
		  } else {
			  alert("Failed: " + data.message);
		  }
	  })
	  .catch(error => {
		  console.error("DoS error:", error);
		  alert("Stopping DoS attack failed");
	  });
}
  
  
      
      


/**
 * The TextScramble function emulates the iconic effect from The Matrix, where text 
 * transitions through random characters before revealing the final message. 
 * 
 * The animation gradually replaces the current characters with random symbols from a 
 * predefined set until it matches the target text. 
 * 
 * This dynamic effect resembles digital code decrypting in real time, creating a 
 * visually striking "hacker-style" appearance.
 */
	class TextScramble {
		constructor(el) {
		    this.el = el
		    
		    // Characters for the scrambling effect
		    this.chars = '!<>-_\\/[]{}—=+*^?#________'
		    
		    // Bind the update method
		    this.update = this.update.bind(this)
		}
		
		// Set the text to be displayed with a scramble effect
		setText(newText) {
		
			// Get the current text
		    const oldText = this.el.innerText
		    
		    // Determine the longest text length
		    const length = Math.max(oldText.length, newText.length)
		    
		    // Promise for when animation completes
		    const promise = new Promise((resolve) => this.resolve = resolve)
		    this.queue = []
		    for (let i = 0; i < length; i++) {
		        const from = oldText[i] || ''								// Current character or empty
		        const to = newText[i] || ''									// Target character or empty
		        const start = Math.floor(Math.random() * 40)				// Random start frame
		        const end = start + Math.floor(Math.random() * 40)			// Random end frame
		        this.queue.push({ from, to, start, end });
		    }
		    
		    // Stop any ongoing animation
		    cancelAnimationFrame(this.frameRequest)
		    this.frame = 0										// Reset the frame counter
		    this.update()										// Start the update loop
		    return promise										// Return the promise
		}
		
		
		// Update the text display
		update() {
		    let output = ''										// The updated text to display
		    let complete = 0									// Count of completed characters
		    
		    for (let i = 0, n = this.queue.length; i < n; i++) {
		        let { from, to, start, end, char } = this.queue[i];


		        if (this.frame >= end) {
		            complete++
		            output += to										// Add the final character if animation is done
		        } else if (this.frame >= start) {
		            if (!char || Math.random() < 0.28) {
		                char = this.randomChar()						// Generate a random character
		                this.queue[i].char = char
		            }
		            output += `<span class="dud">${char}</span>`		// Display the scrambling character
		        } else {
		            output += from										// Add the original character if animation hasn't started
		        }
		    }
		    
		    // Update the element's HTML
		    this.el.innerHTML = output
		    
		    
		    if (complete === this.queue.length) {
		        this.resolve()													// Resolve the promise if all characters are done
		    } else {
		        this.frameRequest = requestAnimationFrame(this.update)			// Continue the animation
		        this.frame++
		    }
		}
		
    	// Generate a random character
		randomChar() {
		    return this.chars[Math.floor(Math.random() * this.chars.length)]
		}
	}



	// Phrases
	const phrases = [
		'Neo,',
		'sooner or later',
		'you\'re going to realize',
		'just as I did',
		'that there\'s a difference',
		'between knowing the path',
		'and walking the path',
		'The Matrix has you.',
		'Free your mind.',
		'There is no spoon.',
		'What is real?',
		'The one is not a savior, but a choice.',
		'It’s not about understanding, it’s about believing.',
		'Reality is just a matter of perception.',
		'The red pill is the only way out.',
		'You’ve been living in a dream world.'
	]

	const el = document.querySelector('.text')			// Target the element with class 'text'
	const fx = new TextScramble(el)

	let counter = 0										// Start with the first phrase
	
	// Function to cycle through the phrases
	const next = () => {
		fx.setText(phrases[counter]).then(() => {
		
			// Wait 3 seconds before the next phrase
		    setTimeout(next, 3000)		
		})
		
		// Loop back to the start when all phrases are done
		counter = (counter + 1) % phrases.length
	}

	// Start the animation
	next()








/**
 * Adds interactive features to the element with ID "tt-symbol":
 * 
 * - Ctrl + Click on the symbol displays a quote box in the bottom right corner with a famous quote.
 * - Shift + Click toggles visibility of all page content except the symbol and background, creating a "focus mode".
 * - Pressing the Escape key closes the quote box if visible and restores hidden content if in focus mode.
 * 
 * Quote box:
 * - Created dynamically with styled container and close (×) button.
 * - Displays a multiline quote with proper formatting.
 * 
 * Content visibility toggle:
 * - Uses visibility:hidden to hide elements without affecting layout.
 * - Tracks hidden elements to restore visibility correctly.
 * 
 */
document.addEventListener("DOMContentLoaded", function() {
    const ttSymbol = document.getElementById("tt-symbol");
    let quoteBox = null;
    let hiddenElements = [];
    let isContentHidden = false;

    // Function to create and show the quote box
    function showQuoteBox() {
        if (quoteBox) return; // Don't create multiple boxes

        // Create a div for the text in the bottom right corner
        quoteBox = document.createElement("div");
        quoteBox.style.position = "fixed";
        quoteBox.style.bottom = "20px";
        quoteBox.style.right = "20px";
        quoteBox.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
        quoteBox.style.color = "white";
        quoteBox.style.padding = "20px";
        quoteBox.style.borderRadius = "5px";
        quoteBox.style.maxWidth = "400px";
        quoteBox.style.zIndex = "10000";
        quoteBox.style.fontFamily = "Arial, sans-serif";
        quoteBox.style.fontSize = "14px";
        quoteBox.style.lineHeight = "1.5";
        quoteBox.style.boxShadow = "0 0 10px rgba(0,0,0,0.5)";
        
        // Add the quotes
		quoteBox.innerHTML = `
			<blockquote style="white-space: pre-wrap; font-style: italic;">
				"The world isn't run by weapons anymore, or energy, or money. It's run by little ones and zeros… It's all just electrons.
				There's a war out there, old friend. A world war. And it's not about who's got the most bullets. It's about who controls the information.
				What we see and hear, how we work, what we think… it's all about the information!"
				- Whistler

				"Too many secrets."
				- Bishop
			</blockquote>
		`;
        
        // Add close button
        const closeButton = document.createElement("button");
        closeButton.textContent = "×";
        closeButton.style.position = "absolute";
        closeButton.style.top = "5px";
        closeButton.style.right = "5px";
        closeButton.style.background = "none";
        closeButton.style.border = "none";
        closeButton.style.color = "white";
        closeButton.style.cursor = "pointer";
        closeButton.style.fontSize = "16px";
        closeButton.style.padding = "5px 8px";
        
        closeButton.addEventListener("click", function() {
            closeQuoteBox();
        });
        
        quoteBox.appendChild(closeButton);
        document.body.appendChild(quoteBox);
    }

    // Function to close the quote box
    function closeQuoteBox() {
        if (quoteBox) {
            document.body.removeChild(quoteBox);
            quoteBox = null;
        }
    }

    // Function to toggle page content visibility
    function toggleContentVisibility() {
        if (isContentHidden) {
            // Restore hidden elements
            hiddenElements.forEach(el => {
                if (el && el.style) {
                    el.style.visibility = 'visible';
                }
            });
            hiddenElements = [];
            isContentHidden = false;
        } else {
            // Hide all elements except body and background
            const allElements = document.querySelectorAll('body *:not(script)');
            hiddenElements = [];
            
            allElements.forEach(el => {
                if (el !== ttSymbol && el.style && getComputedStyle(el).visibility !== 'hidden') {
                    hiddenElements.push(el);
                    el.style.visibility = 'hidden';
                }
            });
            
            isContentHidden = true;
        }
    }

    // Handle TT symbol click
    ttSymbol.addEventListener("click", function(event) {
        if (event.ctrlKey) {
            showQuoteBox();
        } else if (event.shiftKey) {
            toggleContentVisibility();
        }
    });

	// Handle ESC key press
	document.addEventListener('keydown', function(event) {
		if (event.key === 'Escape') {
		    closeQuoteBox();
		    if (isContentHidden) {
		        toggleContentVisibility();
		    }
		}
	});

    // Debug log
    // console.log("ttSymbol initialized");
});






/**
 * Updates the time display with current local time
 * Formats according to user's browser settings
 */
 
// DOM elements
const refreshBtn = document.getElementById('refresh-time');
        
        
/**
 * Shows notification message
 * @param {string} message - The message to display
 * @param {boolean} isError - Whether to show as error
 */
function showNotification(message, isError = false) {
    const notification = document.createElement('div');
    notification.className = `notification ${isError ? 'error' : ''}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Remove after animation completes
    setTimeout(() => {
        notification.remove();
    }, 3000);
}




/**
 * Updates the time display with current local time
 * @returns {number} Current epoch time
 */
function updateTimeDisplay() {
    const now = new Date();
    
    // Time formatting options
    const timeOptions = { 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit',
        hour12: false
    };
    
    // Date formatting options
    const dateOptions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    
    // Update DOM elements
    document.getElementById('current-time').textContent = 
        now.toLocaleTimeString(navigator.language, timeOptions);
    document.getElementById('current-date').textContent = 
        now.toLocaleDateString(navigator.language, dateOptions);
    document.getElementById('timezone').textContent = 
        Intl.DateTimeFormat().resolvedOptions().timeZone;
        
    return Math.floor(now.getTime() / 1000); // Return current epoch time
}




/**
 * Sends time update request to ESP32
 */
function sendTimeUpdateRequest() {
    const epochTime = updateTimeDisplay();
    
    // Add rotating animation
    refreshBtn.classList.add('rotating');
    
    // Send GET request with epoch time
	fetch(`/updatetime?time=${epochTime}`)
		.then(response => {
			if (response.ok) {
				setTimeout(() => {
				    showNotification('ESP32 time synchronized successfully!');
				}, 1000);
			} else {
				throw new Error('Sync failed');
			}
		})
		.catch(error => {
			console.error('Error:', error);
			setTimeout(() => {
				showNotification('Failed to sync with ESP32. RFID may use default (1970).', true);
			}, 1000);
		})
        .finally(() => {
            // Stop rotating after 1 second
            setTimeout(() => {
                refreshBtn.classList.remove('rotating');
            }, 1000);
        });
}

// Initialize time display and update every second
updateTimeDisplay();
setInterval(updateTimeDisplay, 1000);

// Add click event to refresh button
refreshBtn.addEventListener('click', sendTimeUpdateRequest);
    
</script>
        

</body>
</html>
